<?xml version="1.0" encoding="UTF-8"?>
<shelfDocument>
  <!-- This file contains definitions of shelves, toolbars, and tools.
 It should not be hand-edited when it is being used by the application.
 Note, that two definitions of the same element are not allowed in
 a single file. -->

  <toolshelf name="AxeFx_Shelf_tab" label="AxeFx Shelf tab">
    <memberTool name="batchChangePaths_1.1"/>
    <memberTool name="tool_5"/>
    <memberTool name="Principled_to_MTLX"/>
    <memberTool name="Paragon_Importer"/>
    <memberTool name="KB3D_change_mat_res"/>
    <memberTool name="cam_bake"/>
    <memberTool name="Cam_shake"/>
    <memberTool name="mixtrn - 3"/>
    <memberTool name="File_Loader"/>
    <memberTool name="attribmantut"/>
    <memberTool name="XOP_SP_Linker"/>
    <memberTool name="Shader_Converter_echopr"/>
    <memberTool name="Shader Converter"/>
    <memberTool name="principled_from_pat"/>
    <memberTool name="Principled_to_MTLX_v4"/>
    <memberTool name="usd_mat_override"/>
  </toolshelf>


  <tool name="batchChangePaths_1.1" label="Batch Change Paths 1.1" icon="PLASMA_App">
    <script scriptType="python"><![CDATA[import hou
import os

origVar = "$HIP"  # orig string to replace
newVar = "$ASSETS"  # replace with this


obj = hou.node("/obj")



for MaterialBuilders in hou.selectedNodes():
    MaterialBuilderContents = MaterialBuilders.children()
    for child in MaterialBuilderContents:
        childTypeName = child.type().name()
        if childTypeName == "principledshader::2.0":
            # print(f"principled shaders found in {MaterialBuilders.name()} and it is called: {child.name()}")


            ### for each principled shader found, lets check the parameters if they contain "_texture"  ###
            parametersAll = child.parms()
            for parameter in parametersAll:

                try:
                    origstring = parameter.unexpandedString()
                    ###  now we have all parameters in every principled shader that has a "origVar" string in it ###
                    ###  we will now replace the origVar with the "newVar" ###
                    if origVar in origstring:
                        # print(f"parameter is {parameter.unexpandedString()}")
                        sec_part_of_orig_string = origstring.split(origVar)[1]
                        newString = newVar + sec_part_of_orig_string
                        parameter.set(newString)
                        print("new String is: " + newString)
                except:
                    pass


















# for node in MaterialBuilderContents:
#     print(node.name())
#     if node.name() == "principledshader":
#         print(node.name())

    # parms = PrincipledShader.parms()

origStringEval = ""


# for node in nodes:
#
#     parms = node.parms()
#
#     for x in parms:
#         if x.parmTemplate().name() == "file":
#             origstring = x.unexpandedString()
#             print("original String is: " + origstring)
#
#             origStringEval = x.eval()
#             print("original String Evaluated is: " + origStringEval)
#
#             if origstring.startswith(origVar):
#                 sec_part_of_orig_string = origstring.split(origVar)[1]
#                 newString = newVar + sec_part_of_orig_string
#                 print("new String is: " + newString)
#
#                 x.set(newString)
#                 print("new x is: " + x.unexpandedString())

]]></script>
  </tool>

  <tool name="Principled_to_MTLX" label="Principled_to_MTLX" icon="PLASMA_App">
    <script scriptType="python"><![CDATA[##### THIS SCRIPT CONVERT THE CONTENT OF A PRINCIPLED SHADER TEXTURES TO A MATERIALX NETWORK #############
##### LATEST UPDATE  28/06/22
### BY ADRIEN LAMBERT
### GUMROAD.COM/ADRIENLAMBERT


import hou

mysel = hou.selectedNodes()[0]

matcontext = mysel.parent()

matsubnet = matcontext.createNode("subnet", mysel.name() + "_materialX")


## DEFINE OUTPUT SURFACE
surfaceoutput = matsubnet.createNode("subnetconnector", "surface_output")
surfaceoutput.parm("parmname").set("surface")
surfaceoutput.parm("parmlabel").set("Surface")
surfaceoutput.parm("parmtype").set("surface")
surfaceoutput.parm("connectorkind").set("output")


## DEFINE OUTPUT DISPLACEMENT
dispoutput = matsubnet.createNode("subnetconnector", "displacement_output")
dispoutput.parm("parmname").set("displacement")
dispoutput.parm("parmlabel").set("Displacement")
dispoutput.parm("parmtype").set("displacement")
dispoutput.parm("connectorkind").set("output")

#CREATE MATERIALX STANDARD
mtlx =  matsubnet.createNode("mtlxstandard_surface", "surface_mtlx")
surfaceoutput.setInput(0, mtlx)

#CREATE ALBEDO
path = mysel.parm("basecolor_texture").eval()
albedo = matsubnet.createNode("mtlximage", "ALBEDO")
albedo.parm("file").set(path)
mtlx.setInput(1, albedo)

#CREATE ROUGHNESS
path = mysel.parm("rough_texture").eval()
rough = matsubnet.createNode("mtlximage", "ROUGHNESS")
rough.parm("file").set(path)
rough.parm("signature").set("0")
mtlx.setInput(6, rough)

#CREATE SPECULAR
if mysel.parm("reflect_useTexture").eval() == 1:
    path = mysel.parm("reflect_texture").eval()
    spec= matsubnet.createNode("mtlximage", "REFLECT")
    spec.parm("file").set(path)
    mtlx.setInput(5, spec)

#CREATE OPACITY IF NEEDED
if mysel.parm("opaccolor_useTexture").eval() == 1:
    path = mysel.parm("opaccolor_texture").eval()
    opac = matsubnet.createNode("mtlximage", "OPACITY")
    opac.parm("file").set(path)
    mtlx.setInput(38, opac)

    
#CREATE NORMAL
if mysel.parm("baseBumpAndNormal_enable").eval() == 1:
    path = mysel.parm("baseNormal_texture").eval()
    normal = matsubnet.createNode("mtlximage", "NORMAL")
    normal.parm("signature").set("vector3")
    plugnormal = matsubnet.createNode("mtlxnormalmap" )
    normal.parm("file").set(path)
    mtlx.setInput(40, plugnormal)
    plugnormal.setInput(0, normal)
    
    
#CREATE DISPLACEMENT
if mysel.parm("dispTex_enable").eval() == 1:
    # GETTING THE PARAMETERS VALUE
    path = mysel.parm("dispTex_texture").eval()
    offset= mysel.parm("dispTex_offset").eval()
    scale= mysel.parm("dispTex_scale").eval()
    #CREATING DISPLACE NODES
    displace = matsubnet.createNode("mtlximage", "DISPLACE")
    plugdisplace = matsubnet.createNode("mtlxdisplacement" )
    remapdisplace = matsubnet.createNode("mtlxremap", "OFFSET_DISPLACE" )
    #SETTING PARAMETERS DISPLACE
    #set remap
    remapdisplace.parm("outlow").set(offset)
    remapdisplace.parm("outhigh").set(1-offset)
    #set scale displace
    plugdisplace.parm("scale").set(scale)
    #set image displace
    displace.parm("file").set(path)
    displace.parm("signature").set("0")
    
    #SETTING INPUTS
    dispoutput.setInput(0, plugdisplace)
    plugdisplace.setInput(0, remapdisplace)
    remapdisplace.setInput(0, displace)
    


matsubnet.layoutChildren()
]]></script>
  </tool>

  <tool name="clear_Hydra_cache" label="clear Hydra cache" icon="PLASMA_App">
    <script scriptType="python"><![CDATA[panes = hou.ui.paneTabs()
sceneviewers = []
curDesktop = hou.ui.curDesktop()
desktopName = curDesktop.name()
#####identify scene viewers####
for p in panes:
    if p.type() == hou.paneTabType.SceneViewer: 
        sceneviewers.append(p)
              
for v in sceneviewers:
    hou.hscript("texcache -n")
    a = v.restartRenderer()]]></script>
  </tool>

  <tool name="Paragon_Importer" label="Paragon Importer" icon="PLASMA_App">
    <script scriptType="python"><![CDATA[import hou
nodes = hou.selectedNodes()

for node in nodes:
    parms = node.globParms("*_texture")    
    for parm in parms:
        if parm.eval() != "":
            parm_new = parm.eval().replace("_EditorSphere", "")
            parm.set(parm_new)
            print(parm , "/n")]]></script>
  </tool>

  <tool name="KB3D_change_mat_res" label="KB3D change material resolution" icon="PLASMA_App">
    <script scriptType="python"><![CDATA[import hou

origVar = "4k"  # orig string to replace
newVar = """`chs("../../res")`"""  # replace with this

obj = hou.node("/obj")
nodes = hou.selectedNodes()
# matnet = hou.node('/obj/KB3D_EveryCityEmergencyResponse/matnet') #I disabled it but didnt test it yet, enable if problematic



def getPrincipledShaders(kwargs):
    principledShadersList = []
    for matnet in nodes:
        matnetChildren = matnet.children()
        for child in matnetChildren:
            childTypeName = child.type().name()
            if childTypeName == "materialbuilder":
                # print(f"material builder nodes found in {matnet.name()} and it is called: {child.name()}")            
                materialbuilderChildren = child.children()
                for materialbuilderChild in materialbuilderChildren:
                    if materialbuilderChild.type().name() == "principledshader::2.0":
                        # print(f"I found a principled shader called {materialbuilderChild.name()}")
                        principledShader = materialbuilderChild
                        principledShadersList.append(principledShader)
                        # print(f"principledShadersList: {principledShadersList}")
    return principledShadersList


def changeRes(kwargs):
    for principledShader in getPrincipledShaders(kwargs):
        ### for each principled shader found, lets check the parameters if they contain "_texture"  ###
        parametersAll = principledShader.parms()
        parameterTexture= []
        for parameter in parametersAll:
            if parameter.name().endswith("_texture"):
                parameterTexture.append(parameter)
                #print(f"parameters found = {parameterTexture.name()}")


        ###  now we have all parameters in every principled shader that has a "origVar" string in it ###
        ###  we will now replace the origVar with the "newVar" ###
        for x in parameterTexture:
            origString = x.unexpandedString()
            print(f"origString before was {origString}")
            print(f"newvar is {newVar} and its type is")
            if origVar in origString:
                print(f"origVar is {origVar}")
                origString = origString.replace(origVar, newVar)
                print(f"origString after is {origString}")
                x.set(origString)
                #print("new String is: " + newString)




def changeRough(kwargs):
    for principledShader in getPrincipledShaders(kwargs):
        # print(f"principledShader: {principledShader}")            
        parametersAll = principledShader.parms()
        principledShader.parm("rough").set(1)
        print(f"changed roughness !!!!!!!")




# available functions to call from shelf tool :)

changeRes(kwargs)
changeRough(kwargs)
                  ]]></script>
  </tool>

  <tool name="cam_bake" label="Camera Bake" icon="OBJ_camera">
    <script scriptType="python"><![CDATA[import hou

selectedNode = hou.selectedNodes()[0]

bakingNode = hou.node('/obj').createNode('cam', selectedNode.name() + '_bake')


hou.setFrame(int(hou.playbar.playbackRange()[0]))

for f in range(int(hou.playbar.playbackRange()[0]), int(hou.playbar.playbackRange()[1])+1):
    hou.setFrame(f)
    
    bakingNode.setWorldTransform(selectedNode.worldTransform())
    bakingNode.parm("tx").setKeyframe(hou.Keyframe(bakingNode.parm("tx").eval()))
    bakingNode.parm("ty").setKeyframe(hou.Keyframe(bakingNode.parm("ty").eval()))
    bakingNode.parm("tz").setKeyframe(hou.Keyframe(bakingNode.parm("tz").eval()))
    bakingNode.parm("rx").setKeyframe(hou.Keyframe(bakingNode.parm("rx").eval()))
    bakingNode.parm("ry").setKeyframe(hou.Keyframe(bakingNode.parm("ry").eval()))
    bakingNode.parm("rz").setKeyframe(hou.Keyframe(bakingNode.parm("rz").eval()))
    
    
    bakingNode.parm('focal').setKeyframe(hou.Keyframe(selectedNode.parm('focal').eval()))
    bakingNode.parm('aperture').setKeyframe(hou.Keyframe(selectedNode.parm('aperture').eval()))
    bakingNode.parm('near').setKeyframe(hou.Keyframe(selectedNode.parm('near').eval()))
    bakingNode.parm('far').setKeyframe(hou.Keyframe(selectedNode.parm('far').eval()))
    bakingNode.parm('resx').setKeyframe(hou.Keyframe(selectedNode.parm('resx').eval()))
    bakingNode.parm('resy').setKeyframe(hou.Keyframe(selectedNode.parm('resy').eval()))
    bakingNode.parm('winsizex').setKeyframe(hou.Keyframe(selectedNode.parm('winsizex').eval()))
    bakingNode.parm('winsizey').setKeyframe(hou.Keyframe(selectedNode.parm('winsizey').eval()))
    bakingNode.parm('shutter').setKeyframe(hou.Keyframe(selectedNode.parm('shutter').eval()))
    bakingNode.parm('aspect').setKeyframe(hou.Keyframe(selectedNode.parm('aspect').eval()))]]></script>
  </tool>

  <tool name="Cam_shake" label="Cam Shake" icon="OBJ_camera">
    <script scriptType="python"><![CDATA["""
CAMERA SHAKE TOOL
credits to github.com/juanjo4martinez
-----------------
Add some movement to your camera to make it look like it's handheld.
Make sure your Camera node is selected when running this tool!
"""

# Get the selected camera.
this_node = hou.selectedNodes()
this_cam = this_node[0]

# /obj context.
obj = hou.node("/obj")

# Create CHOP Network called "cameraShake".
chopnet = obj.findOrCreateMotionEffectsNetwork()
chopnet.setName(f"cameraShake_{this_cam.name()}", unique_name=True)

# Inside the CHOPNet, create a Channel node and give it a name.
channel_node = chopnet.createNode("channel")
channel_node.setName(f"{this_cam.name()}_rotationClips", unique_name=True)

# Pick the rotation channels from the camera and use "Euler Rotation".
channel_node.parm("name0").set(f"{this_cam.name()}:r")
channel_node.parm("type0").set(1)

# Store the newly created channel's values as individual variables.
channel_value_x = channel_node.parm("value0x")
channel_value_y = channel_node.parm("value0y")
channel_value_z = channel_node.parm("value0z")

# Store the camera's rotation parameters as individual variables.
cam_rot_x = this_cam.parm("rx")
cam_rot_y = this_cam.parm("ry")
cam_rot_z = this_cam.parm("rz")

# CONDITIONAL:
# If rotation is animated, copy those keyframes into the channel's node values.
# If rotation is NOT animated, just copy the camera's rotation values.
if len(cam_rot_x.keyframes()) > 0:
    for k in cam_rot_x.keyframes():
        channel_value_x.setKeyframe(k)    
else: 
    channel_node.parm("value0x").set(this_cam.parm("rx").eval())

if len(cam_rot_y.keyframes()) > 0:
    for k in cam_rot_y.keyframes():
        channel_value_y.setKeyframe(k)
else: 
    channel_node.parm("value0y").set(this_cam.parm("ry").eval())

if len(cam_rot_z.keyframes()) > 0:
    for k in cam_rot_z.keyframes():
        channel_value_z.setKeyframe(k)    
else: 
    channel_node.parm("value0z").set(this_cam.parm("rz").eval())

# Set the channel units to Frames and the graph color to green.
channel_node.parm("units").set(0)
channel_node.parmTuple("gcolor").set((0,1,0))

# Turn off the Export flag on the Channel node.
channel_node.setExportFlag(0)

# Inside the CHOPNet, create a Math node.
math_node = channel_node.parent().createNode("math")
math_node.setName(f"{this_cam.name()}_addNoiseToRotation", unique_name=True)

# The Math node will sum (Add) the rotation channels to the noise.
math_node.parm("chopop").set(1)

# Turn on the Display and Export flags on the Math node.
math_node.setDisplayFlag(1)
math_node.setExportFlag(1)

# Inside the CHOPNet, create a Noise node.
noise_node = chopnet.createNode("noise")

# The name of the noise channels will be the same as in the Channel node (cam:rx,ry,rz).
noise_node.parm("channelname").set(f"`run('chopls {channel_node.path()}')`")

# The seed of the noise will be $C (number of channels, i.e: 3).
noise_node.parm("seed").setExpression("$C")

# Set the roughness to 0 for camera-like movements.
noise_node.parm("rough").set(0)

# Plug the Channel and Noise nodes into the Math inputs.
math_node.setInput(0, channel_node)
math_node.setInput(1, noise_node)

# Layout nodes inside the CHOPNet.
chopnet.layoutChildren()


# CONTROLLERS
# Stores the CHOPNet's parameters as a template.
group = chopnet.parmTemplateGroup()

# Create different parameters to control the effect.
stab = hou.FloatParmTemplate(
    "stab",
    "Stabilization",
    1,
    default_value=[.5],
    min=.1,
    max=1.5,
    help="How stabilized you want your camera to be (0.1 = Shaky footage, >1 = Stabilized footage)."
    )
    
amp = hou.FloatParmTemplate(
    "amp",
    "Amplitude",
    1,
    default_value=[10],
    max=20,
    help="How far the camera moves (0 = No motion, >10 = Wider range)."
    )
    
seed = hou.FloatParmTemplate(
    "seed",
    "Seed",
    1,
    default_value=[1],
    min=0,
    help="Add variation to your camera by changing this value."
    )

# Create a Tab to store the parameters we just created.
folder = hou.FolderParmTemplate(
    "cameraShake",
    "Camera Shake",
    parm_templates=[stab, amp, seed],
    )

# Add the Tab to the CHOPNet's template.
group.append(folder)

# Applies this new template to the CHOPNet.
chopnet.setParmTemplateGroup(group)

# The Â«StabilizationÂ» parameter controls the noise's Â«PeriodÂ» parameter.
noise_node.parm("period").setExpression(f"ch('{chopnet.path()}/stab')")

# The Â«AmpÂ» parameter controls the noise's Â«AmpÂ» parameter
noise_node.parm("amp").setExpression(f"ch('{chopnet.path()}/amp')")

# The Â«SeedÂ» parameter controls the noise's Y Translate (changes the waveform and adds variation).
noise_node.parm("transy").setExpression(f"ch('{chopnet.path()}/seed')")

# Deselect everything except the CHOPNet so the user sees where to tweak the values.
chopnet.setCurrent(1, clear_all_selected=1)
]]></script>
  </tool>

  <tool name="mixtrn - 3" label="mixtrn - 3" icon="PLASMA_App">
    <script scriptType="python"><![CDATA[import hou
import os

texture_path = r"F:\Assets 3D\Models\Props\Flamethrower\textures/"
# print(texture_path)

materials = hou.selectedNodes()[0]
materials_name = materials.name()

### get all shaders
shaders = materials.children()

ArnoldShaders = materials.parent().createNode("matnet", "materials")
ArnoldShaders.moveToGoodPosition()

for shd in shaders:
    shd_type = shd.type().name()
    # print(shd_type)
    if shd_type == "principledshader::2.0":
        ArnoldVopNet = ArnoldShaders.createNode("arnold_materialbuilder",
                                                shd.name())
        ArnoldMatOutput = ArnoldVopNet.children()[0]  # "OUT_material" VOPnode

        ArnoldMat = ArnoldVopNet.createNode("arnold::standard_surface")

        ### connect nodes
        ArnoldMatOutput.setInput(0, ArnoldMat)

        ### get the textures
        basecolor = shd.evalParm("basecolor_texture")
        roughness = shd.evalParm("rough_texture")
        metallic = shd.evalParm("metallic_texture")
        normal = shd.evalParm("baseNormal_texture")

        ### set parameters
        ArnoldMat.parm("specular").set(0)
        ArnoldMat.parm("specular_roughness").set(1)

        if (basecolor != ""):
            basecolor_name = (os.path.split(basecolor)[-1])
            # print(texture_name)

            ### create basecolor texture node
            ArnoldTexBaseColor = ArnoldVopNet.createNode("arnold::image", "basecolor")
            ArnoldTexBaseColor.parm("filename").set(texture_path + basecolor_name)
            ArnoldMat.setInput(1, ArnoldTexBaseColor)

        if (roughness != ""):
            roughness_name = (os.path.split(roughness)[-1])

            ### create roughness texture node
            ArnoldTexRough = ArnoldVopNet.createNode("arnold::image", "roughness")
            ArnoldTexRough.parm("filename").set(texture_path + roughness_name)
            ArnoldMat.setInput(6, ArnoldTexRough)

        if (metallic != ""):
            metallic_name = (os.path.split(metallic)[-1])

            ### create metallic texture node
            ArnoldTexMetal = ArnoldVopNet.createNode("arnold::image", "metallic")
            ArnoldTexMetal.parm("filename").set(texture_path + metallic_name)
            ArnoldMat.setInput(3, ArnoldTexMetal)

        if (normal != ""):
            normal_name = (os.path.split(normal)[-1])

            ### create normal texture node
            ArnoldTexNormal = ArnoldVopNet.createNode("arnold::image", "normal")
            ArnoldTexNormal.parm("filename").set(texture_path + normal_name)
            ArnoldNormalMap = ArnoldVopNet.createNode("arnold::normal_map")
            ArnoldNormalMap.parm("color_to_signed").set(0)
            ArnoldNormalMap.setInput(0, ArnoldTexNormal)
            ArnoldMat.setInput(39, ArnoldNormalMap)


        #
        ArnoldShaders.layoutChildren()
        ArnoldVopNet.layoutChildren()

# Add code to modify contained geometries.
# Use drop down menu to select esxamples.


# p1 = r"$HIP/folder1/folder2/baseColor.jpeg"
# p2 = r"$HIP\folder1\folder2\baseColor.jpeg"
# 
# print(os.path.split(p1)[-1])
# print(os.path.split(p2)[-1])

]]></script>
  </tool>

  <tool name="File_Loader" label="File Loader" icon="PLASMA_App">
    <script scriptType="python"><![CDATA[####    STEPS   ####
# get the file directory
# get the list of files
# create a geo obj
# create a merge node inside


# for every file in filesList:
#   create a file SOP
#   path = file directory + file
#   connect the file SOP to the merge SOP

# append a null after with display and render flags



import hou
import os


obj = hou.node("/obj")
LoaderObj = obj.createNode("geo", "Multi_Loader")

folder = hou.ui.selectFile(title="choose folder to import from",
                           file_type=hou.fileType.Directory)  # Main folder
folder_expanded = hou.text.expandString(folder) # this is new, check "folder" isnt used later.
folderList = os.listdir(folder_expanded)  # Main Folder children list

# create merge and null SOPs
mergeSop = LoaderObj.createNode("merge", "All_merger")
nullMerge = LoaderObj.createNode("null", "OUT_MERGING")
nullMerge.setInput(0, mergeSop, 0)
nullMerge.setDisplayFlag(True)
nullMerge.setRenderFlag(True)


for file in folderList:  # iterate over each file entry and create a file SOP
    if(".fbx" or ".abc" or ".usd") in file:
        LoaderSop = LoaderObj.createNode("file", file)
        LoaderSop.parm("file").set(folder + file)  # set path
        mergeSop.setNextInput(LoaderSop)
    print(os.path.split(file)[-1])  #test 

#cleaning
LoaderObj.layoutChildren()
]]></script>
  </tool>

  <tool name="attribmantut" label="Attribute Manager tut" icon="hicon:/SVGIcons.index?VIEW_display_text.svg">
    <script scriptType="python"><![CDATA[import os
from package1.attribman import attribman
from importlib import reload


reload(attribman)
attribman.show()



print("printed from shelf tool..")]]></script>
  </tool>

  <tool name="XOP_SP_Linker" label="XOP SP Linker" icon="Xolsplink">
    <script scriptType="python"><![CDATA[#Xolotl Studio
#Created by Ymmanuel Flores on 2018
#Copyright 2018 Crowdorchestra SAPI de CV. All rights reserved.
#xolsplink v 1.0.0.8

import hou
import hrpyc
import xolsplink

from PySide2 import QtWidgets,QtCore

class XolSPLinkDialog(QtWidgets.QMainWindow):
    def __init__(self,parent = None):
        super(XolSPLinkDialog,self).__init__(parent)
        self.construct_ui()

    def construct_ui(self):
        self.setWindowTitle("Xolotl SP Live Link")
        self.setStyleSheet(hou.qt.styleSheet())
        self.setProperty("houdiniStyle",True)

        main_widget = QtWidgets.QWidget(self)
        self.setCentralWidget(main_widget)

        g_layout = QtWidgets.QVBoxLayout()
        layoutServer = QtWidgets.QFormLayout()
        layoutMesh = QtWidgets.QFormLayout()
        main_widget.setLayout(g_layout)

        #Add widgets
        self.txtPort = QtWidgets.QLineEdit()
        self.txtPort.setText("8080")
        layoutServer.addRow('Port',self.txtPort)

        self.btnStartServer = QtWidgets.QPushButton('Start Server')
        self.btnStartServer.clicked.connect(self.startServer)
        layoutServer.addRow('',self.btnStartServer)

        self.cbUdim = QtWidgets.QCheckBox()
        layoutMesh.addRow('Udims',self.cbUdim)

        self.cmbNormal = QtWidgets.QComboBox()
        self.cmbNormal.addItem("OpenGL")
        self.cmbNormal.addItem("DirectX")
        layoutMesh.addRow('Format',self.cmbNormal)

        self.cmbRes = QtWidgets.QComboBox()
        self.cmbRes.addItem("128")
        self.cmbRes.addItem("256")
        self.cmbRes.addItem("512")
        self.cmbRes.addItem("1024")
        self.cmbRes.addItem("2048")
        self.cmbRes.addItem("4096")
        layoutMesh.addRow('Resolution',self.cmbRes)


        self.btnSendMesh = QtWidgets.QPushButton('Send Mesh')
        self.btnSendMesh.clicked.connect(self.sendMesh)
        layoutMesh.addRow('',self.btnSendMesh)


        #Main layout
        g_layout.addLayout(layoutServer)
        g_layout.addLayout(layoutMesh)


    def startServer(self):
        port = int(self.txtPort.text())
        try:
            hrpyc.start_server(port=port)
        except:
            print("Xolotl SP Live Link: Server is already listening")

    def sendMesh(self):
        normal = self.cmbNormal.currentText()
        res = self.cmbRes.currentText()
        udims = self.cbUdim.isChecked()
        xolsplink.server.sendMesh(normal,res,udims)

w = XolSPLinkDialog()
w.setWindowFlags(w.windowFlags() & QtCore.Qt.CustomizeWindowHint)
w.setWindowFlags(w.windowFlags() & ~QtCore.Qt.WindowMinMaxButtonsHint)
w.show()
]]></script>
  </tool>

  <tool name="Shader_Converter_echopr" label="Shader Converter 0.1" icon="hicon:/SVGIcons.index?COP2_aidenoise.svg">
    <script scriptType="python"><![CDATA[import shader_conv_echopr as shaderConv

shaderConvWin = shaderConv.ShaderConv()
shaderConvWin.resize(360,500)
shaderConvWin.show()]]></script>
  </tool>

  <tool name="Shader Converter" label="My_Shader_Converter" icon="hicon:/SVGIcons.index?VOP_rainbow.svg">
    <script scriptType="python"><![CDATA[import os
from package1.MaterialsPackage import MaterialsConverter_v1_1 as MC
from importlib import reload

reload(MC)  # reloading the Module
print("\n_____done reloading______")

MatNet = MC.MaterialsCreator()

# MatNet.createMatNet()  # create a MatNet
# print("_____created a Material Network______")


print("_____processing MatNet_to_use______")
MatNet.MatNet_to_use()
print("_____DONE MatNet_to_use()______\n")

print("_____processing Shaders Types______")
MatNet.get_Shaders_type()
print("_____DONE get_Shaders_type()______\n")

print("_____processing Texture Maps Used______")
MatNet.getTextureMapsUsed()
print("_____DONE getTextureMapsUsed______\n")

print("_____processing Arnold Materials______")
MatNet.createArnoldMaterials()  # create Arnold Material
print("_____DONE createArnoldMaterials()______\n")



print("\n")









'''




3/2/2022: [DONE]
    MatNet.createArnoldMaterials() isn't working since we don't have:
        self.matNet_orig
        self.matNet_orig_name
        self.shadersList
        self.MatNet_new

    I need to get those without MatNet.createMatNet() method,
        or maybe stop the reload to keep them in memory
'''

]]></script>
  </tool>

  <tool name="principled_from_pat" label="principled shader from path" icon="hicon:/SVGIcons.index?SOP_texture.svg">
    <script scriptType="python"><![CDATA[#Creates a principle shader with the texture from a path connected
#https://www.linkedin.com/in/jose-gonzalezvfx/

import os

import sys
 
from PySide2.QtWidgets import QDialog, QApplication, QLineEdit, QLabel, QPushButton, QCheckBox, QHBoxLayout, QVBoxLayout
from PySide2.QtCore import Qt

class UI(QDialog):

 
    def __init__(self, parent=None):

        super(UI, self).__init__(parent)
        main_layout = QVBoxLayout()
        self.setWindowTitle("Create shader")
        self.setWindowFlags(self.windowFlags() | Qt.WindowStaysOnTopHint)
        
        #Get Houdini window style and apply to interface
        self.setStyleSheet(hou.qt.styleSheet())
        self.setProperty("houdiniStyle", True)
        
        #Create a path input
        filepath_layout = QHBoxLayout()
        lbl = QLabel("Texture path:")
        self.filepath = QLineEdit("")
        filepath_layout.addWidget(lbl)
        filepath_layout.addWidget(self.filepath)
        filepath_layout.setSpacing(10)
 
        #Create an extension input
        shadername_layout = QHBoxLayout()
        lbl = QLabel("Shader name:")
        self.shadername = QLineEdit("")
        shadername_layout.addWidget(lbl)
        shadername_layout.addWidget(self.shadername)
        shadername_layout.setSpacing(10)
 
        #Set a button to start
        self.button = QPushButton('Create')
 
        #Add all the layout together
        main_layout.addLayout(filepath_layout, stretch=1)
        main_layout.addLayout(shadername_layout, stretch=1)
        main_layout.addWidget(self.button)
        self.setLayout(main_layout)
        
        #Start the main code
        self.button.clicked.connect(self.createshader)

    def createshader(self):

            #Store the path and the extension strings previously input by the user
            path = self.filepath.text()
            shadername = self.shadername.text()

            #Checks if the user closed the path, if not it closes it
            if not path.endswith("\\"):
                path=path + "\\"
                
            shader = hou.node('mat').createNode('principledshader',shadername)

            textures = os.listdir(path)
            
            
            for files in textures:
                    
                texture_path = path+files
                
                texture = hou.node('mat').createNode('texture',files)
                
                
                texture.parm("map").set(texture_path)

                name = files.lower()
                
                if "color" in name or "diff" in name:
                
                    shader.setInput(1,texture,0)
                    texture.moveToGoodPosition()
                    
                    
                elif "rough" in name:
                
                    shader.setInput(6,texture,0)
                    texture.moveToGoodPosition()
                    
                elif "metal" in name:
                
                    shader.setInput(9,texture,0)
                    texture.moveToGoodPosition()
            
                elif "specular" in name or "spec" in name:
                
                    shader.setInput(10,texture,0)
                    texture.moveToGoodPosition()
                    
                elif "emis" in name:
                
                    shader.setInput(27,texture,0)
                    texture.moveToGoodPosition()
                    
                elif "bump" in name or "normal" in name:
                
                    texture.destroy()
                    shader.parm("baseBumpAndNormal_enable").set(True)
                    
                    if "bump" in name:
                            shader.parm("baseBumpAndNormal_type").set("Bump")
                            shader.parm("baseBump_bumpTexture").set(texture_path)
                            
                    else:
                            shader.parm("baseNormal_texture").set(texture_path)
                        
                    
                elif "height" in name or "disp" in name or "depth" in name:
                
                    texture.destroy()
                    shader.parm("dispTex_enable").set(True)
                    shader.parm("dispTex_texture").set(texture_path)
                    
                    
                else:
                
                    hou.ui.displayMessage("Couldnt connect " +files, severity=hou.severityType.Message, default_choice=0, close_choice=0, title="Texture not applied",details_expanded=False)
                    texture.moveToGoodPosition()
                
            
            shader.moveToGoodPosition()
            

#Starts the script window for the user
app = QApplication.instance()
if app is None: 
    app = QApplication(sys.argv)      
shaderUI = UI()
shaderUI.show()]]></script>
  </tool>

  <tool name="Principled_to_MTLX_v4" label="Principled_to_MTLX_v4" icon="PLASMA_App">
    <script scriptType="python"><![CDATA[##### THIS SCRIPT CONVERT THE CONTENT OF A PRINCIPLED SHADER TEXTURES TO A MATERIALX NETWORK (+ USD PREVIEW OPTIONAL)#############
##### LATEST UPDATE  18/09/23 - v004
### BY ADRIEN LAMBERT
### GUMROAD.COM/ADRIENLAMBERT


import hou

class materialconverter():

    def __init__(self):
        global mysel
        mysel = hou.selectedNodes()
        self.safetycheck()
        
    ###### SAFETY TO CHECK THE CURRENT SELECTION, IF NOTHING OR IF NOT A PRINCIPLE SHADER THEN SHOW A MESSAGE
    def safetycheck(self):
        if mysel==():
            hou.ui.displayMessage("Please select a principleShader to convert")
        else :
            type = mysel[0].type()
            if type.name() == "principledshader::2.0":
                self.filtermaterial()
                
            else:
                hou.ui.displayMessage("Current selected node is a : " + type.description() + """
                
                You need to select a node of type PrincipledShader""")
                
    ###### CREATE A UI TO SEND CONVERTED RESULT INTO  A MATERIAL LIBRARY           
    def filtermaterial(self):
        
        #function to find materiallibrary in prompt dialog
        def ismatlibrary(node):
            # Only show nodes which are material library
            if node.type().name() == "materiallibrary":
                return True
            else:
                # Don't show nodes that arent material library
                return False
        
        findlib=[]
        stage= hou.node("/stage")
        nodes = stage.allSubChildren()
        for n in nodes:
            if n.type().name() == "materiallibrary":
                findlib.append(n)
                #if no material library then convert in current network

        if findlib == []:
            path = hou.selectedNodes()[0].parent()
            self.mtlxConvert(path.path())
        

        # if material library in scene Prompt the user to select node data.
        else:
            
            selected_data = hou.ui.selectNode(custom_node_filter_callback=ismatlibrary)
            
            # Output the selected data.
            if selected_data != None:
                #Executing materialX conversion and sending the path of the selected materialLibrary into it
                self.mtlxConvert(selected_data)
    
                previewUI = hou.ui.displayMessage("Do you wish to create a USD preview ?", buttons=["YES", "NO"])
                if previewUI == 0:
                    self.usdpreview(selected_data)
                else:
                    pass
    
    def usdpreview(self, path):

        matcontext = hou.node(path)
        #mysel = hou.selectedNodes()[0]
        usdmat = matcontext.createNode("usdpreviewsurface", mysel.name() + "_previewUSD")
        
        albedo = matcontext.createNode("usduvtexture::2.0", "USD_albedo")
        rough = matcontext.createNode("usduvtexture::2.0", "USD_roughness")
        primvar = matcontext.createNode("usdprimvarreader","usd_primvar_ST")
        
        primvar.parm("signature").set("float2")
        primvar.parm("varname").set("st")
        
        #connect USD MAT with textures
        usdmat.setInput(0, albedo,4 )
        usdmat.setInput(5, rough,4 )
        
        #connect USD textures with primvar
        albedo.setInput(1, primvar, 0)
        rough.setInput(1, primvar, 0)
        
        #set albedo path
        path = mysel.parm("basecolor_texture").eval()
        albedo.parm("file").set(path)
        
        #set roughness path
        path = mysel.parm("rough_texture").eval()
        rough.parm("file").set(path)
        
        #create opacity if exists
        if mysel.parm("opaccolor_useTexture").eval() == 1:
            path = mysel.parm("opaccolor_texture").eval()
            opacity = matcontext.createNode("usduvtexture::2.0", "USD_opacity")
            opacity.parm("file").set(path)
            opacity.setInput(1, primvar, 0)
            usdmat.setInput(8, opacity, 0)
            
        #set USDpreview settings
        usdmat.parm("opacityThreshold").set(0.2)
        usdmat.parm("useSpecularWorkflow").set(1)
        matcontext.layoutChildren()
            
        test = matcontext.outputs()
        if len(test)>0:
            if (test[0].type().description()) == "Component Material":
                #setting component material - materialpath with mtlX
                test[0].parm("matspecpath1").set("/ASSET/mtl/" + matsubnet.name()  )
                
                #creating assign material within componentMaterial
                edit = test[0].node("edit")
                assign = edit.createNode("assignmaterial")
                output = edit.node("output0")
                subinputs = edit.indirectInputs()[0] 
                assign.setInput(0, subinputs)
                output.setInput(0, assign)
                edit.layoutChildren()
                #setting assign material
                assign.parm("matspecpath1").set("/ASSET/mtl/" + usdmat.name())
                assign.parm("primpattern1").set("/*")
                
                purpose = assign.parm("bindpurpose1")
                purpose.set(purpose.menuItems()[-1])
                

        
    ###### CREATION MATERIAL X SUBNET CONTENT BASED ON THE SELECTED MATERIAL LIBRARY
    def mtlxConvert(self, path):
        matcontext = hou.node(path)
        global mysel
        mysel = hou.selectedNodes()[0]
        
        global matsubnet
        matsubnet = matcontext.createNode("subnet", mysel.name() + "_materialX")
        
        
        ## DEFINE OUTPUT SURFACE
        surfaceoutput = matsubnet.createNode("subnetconnector", "surface_output")
        surfaceoutput.parm("parmname").set("surface")
        surfaceoutput.parm("parmlabel").set("Surface")
        surfaceoutput.parm("parmtype").set("surface")
        surfaceoutput.parm("connectorkind").set("output")
        
        
        ## DEFINE OUTPUT DISPLACEMENT
        dispoutput = matsubnet.createNode("subnetconnector", "displacement_output")
        dispoutput.parm("parmname").set("displacement")
        dispoutput.parm("parmlabel").set("Displacement")
        dispoutput.parm("parmtype").set("displacement")
        dispoutput.parm("connectorkind").set("output")
        
        #CREATE MATERIALX STANDARD
        mtlx =  matsubnet.createNode("mtlxstandard_surface", "surface_mtlx")
        surfaceoutput.setInput(0, mtlx)
        
        #CREATE ALBEDO
        path = mysel.parm("basecolor_texture").eval()
        albedo = matsubnet.createNode("mtlximage", "ALBEDO")
        albedo.parm("file").set(path)
        mtlx.setInput(1, albedo)
        
        #CREATE METALLIC
        if mysel.parm("metallic_useTexture").eval() == 1:
            path = mysel.parm("metallic_texture").eval()
            metal = matsubnet.createNode("mtlximage", "METALLIC")
            metal.parm("signature").set("0")
            metal.parm("file").set(path)
            mtlx.setInput(3, metal)

        #CREATE ROUGHNESS
        path = mysel.parm("rough_texture").eval()
        rough = matsubnet.createNode("mtlximage", "ROUGHNESS")
        rough.parm("file").set(path)
        rough.parm("signature").set("0")
        mtlx.setInput(6, rough)
        
        #CREATE SPECULAR
        if mysel.parm("reflect_useTexture").eval() == 1:
            path = mysel.parm("reflect_texture").eval()
            spec= matsubnet.createNode("mtlximage", "REFLECT")
            spec.parm("file").set(path)
            mtlx.setInput(5, spec)
        
        #CREATE OPACITY IF NEEDED
        if mysel.parm("opaccolor_useTexture").eval() == 1:
            path = mysel.parm("opaccolor_texture").eval()
            opac = matsubnet.createNode("mtlximage", "OPACITY")
            opac.parm("file").set(path)
            mtlx.setInput(38, opac)
        
        
            
        #CREATE NORMAL
        if mysel.parm("baseBumpAndNormal_enable").eval() == 1:
            path = mysel.parm("baseNormal_texture").eval()
            normal = matsubnet.createNode("mtlximage", "NORMAL")
            normal.parm("signature").set("vector3")
            plugnormal = matsubnet.createNode("mtlxnormalmap" )
            normal.parm("file").set(path)
            mtlx.setInput(40, plugnormal)
            plugnormal.setInput(0, normal)
            

            
            
        #CREATE DISPLACEMENT
        if mysel.parm("dispTex_enable").eval() == 1:
            # GETTING THE PARAMETERS VALUE
            path = mysel.parm("dispTex_texture").eval()
            offset= mysel.parm("dispTex_offset").eval()
            scale= mysel.parm("dispTex_scale").eval()
            #CREATING DISPLACE NODES
            displace = matsubnet.createNode("mtlximage", "DISPLACE")
            plugdisplace = matsubnet.createNode("mtlxdisplacement" )
            remapdisplace = matsubnet.createNode("mtlxremap", "OFFSET_DISPLACE" )
            #SETTING PARAMETERS DISPLACE
            #set remap
            remapdisplace.parm("outlow").set(offset)
            remapdisplace.parm("outhigh").set(1+offset)
            #set scale displace
            plugdisplace.parm("scale").set(scale)
            #set image displace
            displace.parm("file").set(path)
            displace.parm("signature").set("0")
            
            #SETTING INPUTS
            dispoutput.setInput(0, plugdisplace)
            plugdisplace.setInput(0, remapdisplace)
            remapdisplace.setInput(0, displace)
            
        
        
        matsubnet.layoutChildren()
        matsubnet.setSelected(True, True)
        
materialconverter()
]]></script>
  </tool>

  <tool name="usd_mat_override" label="usd_mat_override" icon="hicon:/SVGIcons.index?VOP_usdpreviewsurface.svg">
    <script scriptType="python"><![CDATA[
"""
Author : Mahmoud Kamal 2022-2023

This script to extracting information about shaders from usd sublayer node, specifically their type, properties, and connections to other nodes.

The script gets the stage from the usdz file.
then iterates through all the prims (basic building blocks that make up a scene) in the stage using TraverseAll().

For each prim, if it is a shader, the script extracts its name, type, and properties.
It also checks if the shader has a material:binding relationship, which indicates that it is assigned to a mesh.

For each property of the shader, the script extracts its name, type, and value.
It also checks if the property is connected to another node, and if so, it extracts the name, type, and connected attribute of the other node.
This information is stored in a dictionary called shader_data.


"""

import os
import pprint
import json
import pxr.Usd as Usd
import pxr.UsdGeom as UsdGeom
import hou
from importlib import reload

class SolarisMaterialOverride:
    def init_data(self,input_usd_file=None, target_stage=None):

        stage = None
        prims = None
        if not input_usd_file:
            if target_stage:

                stage = target_stage.stage()
            else:
                raise Exception("Sorry, You need to set input usd file path or set stage node")
                return stage, prims
        else:
            if not target_stage:
                stage = Usd.Stage.Open(input_file)

            else:
                raise Exception("Sorry, You need to set input usd file path or set stage node")
                return stage, prims

        prims = stage.TraverseAll()
        print(f'init_data()----- {prims=} \n')
        return stage, prims


    def collect_data_Arnold(self, input_usd_file=None, target_stage=None):              ### this is currently limited to Arnold usd shaders, need to refactor for usdPreviewSurface
        stage, prims = self.init_data(input_usd_file, target_stage)
        shader_data = {}
        assign_data = {}

        if not stage and not prims:
            return shader_data,assign_data

        for prim in prims:
            if prim:
                prim_name = prim.GetName()
                if prim.GetTypeName() != 'Material':
                    if prim.HasRelationship('material:binding'):
                        # Get assigned material to the mesh
                        material_binding = prim.GetRelationship('material:binding').GetTargets()
                        if material_binding[0].GetPrimPath() not in assign_data:
                            assign_data[material_binding[0].GetPrimPath()] = []
                        assign_data[material_binding[0].GetPrimPath()].append(prim.GetPrimPath())

                if prim.GetTypeName() == 'Material':
                    print(f'collect_Arnold_data()----- {prim=} \n')

                    material_path = str(prim.GetPrimPath()).split(prim.GetName())[0]
                    # print(f'collect_Arnold_data()----- {material_path=} \n')
                    shader_data[prim.GetName()] = {}
                    shader_data[prim.GetName()]["path"] = material_path
                    shader_data[prim.GetName()]["children"] = {}
                    print(f'collect_Arnold_data()----- {shader_data=} \n')

                    if prim.HasRelationship('material:binding'):
                        ### Get assigned material to the mesh
                        material_binding = prim.GetRelationship('material:binding').GetTargets()
                        print(f'collect_Arnold_data()----- {material_binding=} \n')

                    for shader_node in prim.GetChildren():

                        shader_node_type = shader_node.GetAttribute("info:id").Get()
                        shader_node_name = shader_node.GetName()
                        shader_data[prim.GetName()]["children"][shader_node_name] = {}
                        shader_data[prim.GetName()]["children"][shader_node_name]["node_type"] = shader_node_type
                        shader_data[prim.GetName()]["children"][shader_node_name]["attributes"] = {}
                        print(f'collect_Arnold_data()----- {shader_data[prim.GetName()]["children"]=}')
                        for attribute in shader_node.GetProperties():  ### gets all shader primvars
                            attribute_name = attribute.GetName()
                            if "info" in attribute_name:
                                continue

                            attribute_value = shader_node.GetAttribute(attribute_name).Get()

                            if attribute_name != "material:binding":
                                print(f'collect_Arnold_data()----- {attribute_name=}')
                                if "inputs" in attribute_name:
                                    shader_data[prim.GetName()]["children"][shader_node_name]["attributes"][attribute_name] = {}
                                    shader_data[prim.GetName()]["children"][shader_node_name]["attributes"][attribute_name]["value"] = attribute_value
                                    print(f'collect_Arnold_data()----- {shader_data[prim.GetName()]["children"][shader_node_name]["attributes"][attribute_name]=}')

                                    if attribute.GetConnections():
                                        shader_data[prim.GetName()]["children"][shader_node_name]["attributes"][attribute_name]["connections"] = {}
                                        connected_node_path = shader_node.GetProperty(attribute_name).GetConnections()[0].GetPrimPath()
                                        connected_node = stage.GetPrimAtPath(connected_node_path)
                                        connected_node_type = connected_node.GetAttribute("info:id").Get()
                                        connected_node_name = connected_node.GetName()
                                        connected_node_attrib = str(shader_node.GetProperty(attribute_name).GetConnections()[0]).split(".")[1]

                                        shader_data[prim.GetName()]["children"][shader_node_name]["attributes"][attribute_name]["connections"][connected_node_name] = {}
                                        shader_data[prim.GetName()]["children"][shader_node_name]["attributes"][attribute_name]["connections"][connected_node_name]["node_type"] = connected_node_type
                                        shader_data[prim.GetName()]["children"][shader_node_name]["attributes"][attribute_name]["connections"][connected_node_name]["connected_node_attribute"] = connected_node_attrib

        # def print_nested_dictionaries(dictionary):
        #     for key, value in dictionary.items():
        #         if isinstance(value, dict):
        #             print_nested_dictionaries(value)
        #         else:
        #             print(f"{key}: {value}")
        # print_nested_dictionaries(shader_data)
        return shader_data, assign_data


    def collect_data_USDPreview(self, input_usd_file=None, target_stage=None):              ### this is currently limited to Arnold usd shaders, need to refactor for usdPreviewSurface
        stage, prims = self.init_data(input_usd_file, target_stage)
        shader_data = {}
        assign_data = {}

        if not stage and not prims:
            return shader_data,assign_data

        for prim in prims:
            if prim:
                prim_name = prim.GetName()
                if prim.GetTypeName() != 'Material':
                    if prim.HasRelationship('material:binding'):
                        # Get assigned material to the mesh
                        material_binding = prim.GetRelationship('material:binding').GetTargets()
                        if material_binding[0].GetPrimPath() not in assign_data:
                            assign_data[material_binding[0].GetPrimPath()] = []
                        assign_data[material_binding[0].GetPrimPath()].append(prim.GetPrimPath())

                if prim.GetTypeName() == 'Material':
                    print(f'collect_data_USDPreview()----- {prim=} \n')

                    material_path = str(prim.GetPrimPath()).split(prim.GetName())[0]
                    # print(f'collect_data_USDPreview()----- {material_path=} \n')
                    shader_data[prim.GetName()] = {}
                    shader_data[prim.GetName()]["path"] = material_path
                    shader_data[prim.GetName()]["children"] = {}
                    print(f'collect_data_USDPreview()----- {shader_data=} \n')

                    if prim.HasRelationship('material:binding'):
                        ### Get assigned material to the mesh
                        material_binding = prim.GetRelationship('material:binding').GetTargets()
                        print(f'collect_data_USDPreview()----- {material_binding=} \n')

                    for shader_node in prim.GetChildren():

                        shader_node_type = shader_node.GetAttribute("info:id").Get()
                        shader_node_name = shader_node.GetName()
                        shader_data[prim.GetName()]["children"][shader_node_name] = {}
                        shader_data[prim.GetName()]["children"][shader_node_name]["node_type"] = shader_node_type
                        shader_data[prim.GetName()]["children"][shader_node_name]["attributes"] = {}
                        # print(f'collect_data_USDPreview()----- {shader_data[prim.GetName()]["children"]=}')
                        for attribute in shader_node.GetProperties():                   ### gets all shader primvars
                            attribute_name = attribute.GetName()
                            if "info" in attribute_name:
                                continue

                            attribute_value = shader_node.GetAttribute(attribute_name).Get()

                            if attribute_name != "material:binding":
                                print(f'collect_data_USDPreview()----- {attribute_name=}')
                                if "inputs" in attribute_name:
                                    shader_data[prim.GetName()]["children"][shader_node_name]["attributes"][attribute_name] = {}
                                    shader_data[prim.GetName()]["children"][shader_node_name]["attributes"][attribute_name]["value"] = attribute_value
                                    print(f'collect_data_USDPreview()----- {shader_data[prim.GetName()]["children"][shader_node_name]["attributes"][attribute_name]=}')

                                    if attribute.GetConnections():
                                        shader_data[prim.GetName()]["children"][shader_node_name]["attributes"][attribute_name]["connections"] = {}
                                        connected_node_path = shader_node.GetProperty(attribute_name).GetConnections()[0].GetPrimPath()
                                        connected_node = stage.GetPrimAtPath(connected_node_path)
                                        connected_node_type = connected_node.GetAttribute("info:id").Get()
                                        connected_node_name = connected_node.GetName()
                                        connected_node_attrib = str(shader_node.GetProperty(attribute_name).GetConnections()[0]).split(".")[1]

                                        shader_data[prim.GetName()]["children"][shader_node_name]["attributes"][attribute_name]["connections"][connected_node_name] = {}
                                        shader_data[prim.GetName()]["children"][shader_node_name]["attributes"][attribute_name]["connections"][connected_node_name]["node_type"] = connected_node_type
                                        shader_data[prim.GetName()]["children"][shader_node_name]["attributes"][attribute_name]["connections"][connected_node_name]["connected_node_attribute"] = connected_node_attrib

        # def print_nested_dictionaries(dictionary):
        #     for key, value in dictionary.items():
        #         if isinstance(value, dict):
        #             print_nested_dictionaries(value)
        #         else:
        #             print(f"{key}: {value}")
        # print_nested_dictionaries(shader_data)
        return shader_data, assign_data


    def create_shaders_Arnold(self, input_usd_file=None, target_stage=None):
        """
        Extract data from usd and start build material networks
        """
        shader_data, assign_data = self.collect_data_Arnold(input_usd_file, target_stage)
        if not shader_data and not assign_data:
            return shader_data, assign_data
        stage = hou.node("/stage")
        mat_lib = stage.createNode("materiallibrary")
        mat_lib.moveToGoodPosition()
        counter = 0
        # print(f'create_override_shaders()----- {shader_data=} \n')
        for shader in shader_data:
            # print(f'create_override_shaders()----- {shader=} \n')
            arnold_net = mat_lib.createNode("arnold_materialbuilder", shader)
            mat_lib.parm("materials").set(counter)
            if counter == 0:
                mat_lib.parm("matpathprefix").set(shader_data[shader]["path"])
                # mat_lib.parm("fillmaterials").pressButton()
            counter += 1

        for node in shader_data[shader]["children"]:                                                ###gets all nodes inside shader networks like Standard Surf
            """
            Create all shader nodes
            """
            # print(f'create_override_shaders()----- {node=} \n')
            # print(f'create_override_shaders()----- {shader_data[shader]["children"][node]["node_type"]=} \n')
            node_type = shader_data[shader]["children"][node]["node_type"].split(":")[1]            ### gets node_type of eg. stnd Surf, remove splitting for usdPreviewSurface

            shader_node = arnold_net.createNode(node_type, node)
            if shader_node.type().name() == "arnold::standard_surface":                             ### need a similar loop for usdPreviewSurface
                """
                If the node is material node
                connect it with 'out node(shading group)' and set material lib node parameter
                """
                mat_lib.parm("materials").set(counter)
                mat_lib.parm("matpath{}".format(counter)).set(shader_data[shader]["path"]+shader)
                mat_lib.parm("matnode{}".format(counter)).set(shader)
                out_material_node = arnold_net.node("OUT_material")
                out_material_node.setInput(0,shader_node,0)

        # for node in shader_data[shader]["children"]:                                                        ### this is a duplicate for loop, why?
            shader_node = arnold_net.node(node)                                                             ### gets the hou.node shader e.g. Std Surf
            # print(f'create_override_shaders()----- {shader_node=} \n')

            for attribute in shader_data[shader]["children"][node]["attributes"]:                           ### loops over all attribs on shader
                """
                Set parameter values and parameters connections with other nodes
                """
                # print(f'create_override_shaders()----- {attribute=}')                                       ### returns e.g. 'inputs:specular_roughness'
                attribute_value = shader_data[shader]["children"][node]["attributes"][attribute]["value"]   ### gets all attribs values
                # print(f'create_override_shaders()----- {attribute_value=}')                                 ### returns 0.095
                attribute_name = "{}".format(attribute.split(":")[1])
                # print(f'create_override_shaders()----- {attribute_name=} \n')                               ### returns e.g. 'specular_roughness'
                if attribute_name:
                    # print( shader_node,attribute_name,attribute_value)

                    if "connections" not in shader_data[shader]["children"][node]["attributes"][attribute]:
                        """
                        Set parameter values  
                        """
                        if shader_node.parm(attribute_name):                                                ### checks if the created shader e.g. std surf has the attribute_name we are looping over
                            parm_type = type(shader_node.parm(attribute_name).eval())
                            # if "@" in attribute_value:                                                    ### gives me errors so I disabled it
                            #     attribute_value = attribute_value.strip("@")
                            shader_node.parm(str(attribute_name)).set(parm_type(attribute_value))           ### sets that parameter to be attribute_value we have
                    else:
                        """
                        Set parameter connections with other nodes
                        """
                        for connected_node in shader_data[shader]["children"][node]["attributes"][attribute]["connections"]:
                            connected_node_name = arnold_net.node(connected_node)

                            output_connected_attribute = shader_data[shader]["children"][node]["attributes"][attribute]["connections"][connected_node]["connected_node_attribute"]

                            input_index = shader_node.inputIndex(attribute_name)

                            output_index = connected_node_name.outputIndex(output_connected_attribute.split(":")[1])

                            inputs = shader_node.input(input_index)
                            if not inputs:
                                shader_node.insertInput(input_index, connected_node_name, output_index)

                # shader_node.parm("{}".format(attribute.split(":")[1])).set(attribute_value)
        print('\n \n')
        return shader_data, assign_data, mat_lib

    def create_shaders_USDPreview(self, input_usd_file=None, target_stage=None):
        """
        Extract data from usd and start build material networks
        """
        shader_data, assign_data = self.collect_data_USDPreview(input_usd_file, target_stage)
        if not shader_data and not assign_data:
            return shader_data, assign_data
        stage = hou.node("/stage")
        mat_lib = stage.createNode("materiallibrary")
        mat_lib.moveToGoodPosition()
        counter = 0
        # print(f'create_override_shaders()----- {shader_data=} \n')
        for shader in shader_data:
            # print(f'create_override_shaders()----- {shader=} \n')
            subnetwork = mat_lib.createNode('subnet', shader)
            mat_lib.parm("materials").set(counter)
            if counter == 0:
                mat_lib.parm("matpathprefix").set(shader_data[shader]["path"])
                # mat_lib.parm("fillmaterials").pressButton()
            counter += 1

        for node in shader_data[shader]["children"]:                                                ###gets all nodes inside shader networks like Standard Surf
            """
            Create all shader nodes
            """
            # print(f'create_override_shaders()----- {node=} \n')
            # print(f'create_override_shaders()----- {shader_data[shader]["children"][node]["node_type"]=} \n')
            node_type = shader_data[shader]["children"][node]["node_type"]                          ### gets node_type of eg. stnd Surf, remove splitting for usdPreviewSurface
            print(f'create_shaders_USDPreview()----- {node_type=}')

            shader_node = subnetwork.createNode(node_type.lower(), node)
            if shader_node.type().name() == "arnold::standard_surface":                             ### need a similar loop for usdPreviewSurface
                """
                If the node is material node
                connect it with 'out node(shading group)' and set material lib node parameter
                """
                mat_lib.parm("materials").set(counter)
                mat_lib.parm("matpath{}".format(counter)).set(shader_data[shader]["path"]+shader)
                mat_lib.parm("matnode{}".format(counter)).set(shader)
                out_material_node = subnetwork.node("OUT_material")
                out_material_node.setInput(0, shader_node, 0)

        # for node in shader_data[shader]["children"]:                                                      ### this is a duplicate for loop, why?
            shader_node = subnetwork.node(node)                                                             ### gets the hou.node shader e.g. Std Surf
            # print(f'create_override_shaders()----- {shader_node=} \n')

            for attribute in shader_data[shader]["children"][node]["attributes"]:                           ### loops over all attribs on shader
                """
                Set parameter values and parameters connections with other nodes
                """
                # print(f'create_override_shaders()----- {attribute=}')                                       ### returns e.g. 'inputs:specular_roughness'
                attribute_value = shader_data[shader]["children"][node]["attributes"][attribute]["value"]   ### gets all attribs values
                # print(f'create_override_shaders()----- {attribute_value=}')                                 ### returns 0.095
                attribute_name = "{}".format(attribute.split(":")[1])
                # print(f'create_override_shaders()----- {attribute_name=} \n')                               ### returns e.g. 'specular_roughness'
                if attribute_name:
                    # print( shader_node,attribute_name,attribute_value)

                    if "connections" not in shader_data[shader]["children"][node]["attributes"][attribute]:
                        """
                        Set parameter values  
                        """
                        if shader_node.parm(attribute_name):                                                ### checks if the created shader e.g. std surf has the attribute_name we are looping over
                            parm_type = type(shader_node.parm(attribute_name).eval())
                            # if "@" in attribute_value:                                                    ### gives me errors so I disabled it
                            #     attribute_value = attribute_value.strip("@")
                            shader_node.parm(str(attribute_name)).set(parm_type(attribute_value))           ### sets that parameter to be attribute_value we have
                    else:
                        """
                        Set parameter connections with other nodes
                        """
                        for connected_node in shader_data[shader]["children"][node]["attributes"][attribute]["connections"]:
                            connected_node_name = subnetwork.node(connected_node)
                            output_connected_attribute = shader_data[shader]["children"][node]["attributes"][attribute]["connections"][connected_node]["connected_node_attribute"]
                            input_index = shader_node.inputIndex(attribute_name)
                            output_index = connected_node_name.outputIndex(output_connected_attribute.split(":")[1])
                            inputs = shader_node.input(input_index)
                            if not inputs:
                                shader_node.insertInput(input_index, connected_node_name, output_index)

                # shader_node.parm("{}".format(attribute.split(":")[1])).set(attribute_value)
        return shader_data, assign_data, mat_lib


    def assign_materials(self, assign_data):
        """
        Create necessary nodes to assign materials to the objects
        using collection node and material assign node
        """
        stage = hou.node("/stage")
        collection_node = stage.createNode("collection")
        collection_node.moveToGoodPosition()
        collection_node.parm("collectioncount").set(len(assign_data))
        material_assign_node =  stage.createNode("assignmaterial")
        material_assign_node.moveToGoodPosition()
        material_assign_node.parm("nummaterials").set(len(assign_data))
        counter = 1
        for material in assign_data:
            material_name = str(material).split("/")[-1]
            material_path = str(material).split(str(material).split("/")[-1])[0]
            collection_node.parm("collectionname{}".format(counter)).set(material_name)
            if counter == 1:
                path = material_path + "collections"
                collection_node.parm("defaultprimpath").set(path)
            for object in assign_data[material]:
                collection_val = collection_node.parm("includepattern{}".format(counter)).eval()
                collection_val = collection_val + "\n" + str(object.GetPrimPath())
                collection_node.parm("includepattern{}".format(counter)).set(collection_val)
                #/Asset/collections.collection:big_robot_steel_Shader
            material_assign_node.parm("primpattern{}".format(counter)).set("{}.collection:{}".format(path,material_name))
            material_assign_node.parm("matspecpath{}".format(counter)).set(material_path+material_name)

            counter += 1
        return collection_node,material_assign_node

    def run_override(self, input_usd_file=None, target_stage=None):
        # import trend_importer
        # reload(trend_importer)
        # importer = trend_importer.TrendImporter(None, None)

        shader_data, assign_data, mat_lib  = self.create_shaders_Arnold(input_usd_file, target_stage)
        collection_node, material_assign_node = self.assign_materials(assign_data)
        if target_stage:
            mat_lib.setInput(0, target_stage)
        if collection_node and material_assign_node:
            collection_node.setInput(0,mat_lib)
            material_assign_node.setInput(0, collection_node)
            # importer.create_network_box([collection_node,material_assign_node,mat_lib], "Material_Override")


    def run_debug(self, input_usd_file=None, target_stage=None):
        # import trend_importer
        # reload(trend_importer)
        # importer = trend_importer.TrendImporter(None, None)

        shader_data, assign_data, mat_lib  = self.create_shaders_USDPreview(input_usd_file, target_stage)
        collection_node, material_assign_node = self.assign_materials(assign_data)
        if target_stage:
            mat_lib.setInput(0, target_stage)
        if collection_node and material_assign_node:
            collection_node.setInput(0,mat_lib)
            material_assign_node.setInput(0, collection_node)
            # importer.create_network_box([collection_node,material_assign_node,mat_lib], "Material_Override")




node = hou.node('/stage/x')

data = SolarisMaterialOverride().run_debug(target_stage=node)

]]></script>
  </tool>
</shelfDocument>
